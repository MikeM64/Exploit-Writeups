# PlayStation 3 - lv0ldr: Teensy in the Middle
# Table of Contents
- Introduction
- Acknowledgements
- Abbreviations
- History: Where did we leave off?
- PlayStation 3 SPI Architecture
- Syscon/Southbridge SPI Bus
    + Overview
    + Bus Transfer Protocol
    + Syscon SPI Packet Protocol
- Juan Nadie's lv0ldr Software Exploit
- Working backwards from outside to inside
    + Arbitrary SPI Read and Write
    + Dynamic Controller Selection
    + Priming lv0ldr
    + Replacing SPU Interrupts with Luck
- CECH-2500 Exploit Setup

# Introduction
NOTE: I do not condone or endorse piracy. As such, neither this exploit or write up will contain anything to enable piracy on the system.

Welcome to my write up on how to exploit lv0ldr using hardware on most PlayStation 3 systems. You can find the full source for the exploit in the repository [here](https://github.com/MikeM64/ps3-lv0ldr-teensy). The full setup required to use the exploit is described below in the section "CECH-2500 Exploit Setup".
This exploit is a hardware-based implementation of the one released by Juan Nadie and the Three Musketeers back in 2012.

# Acknowledgements
- Thanks to Jestero and M4j0r for your assistance and knowledge in getting this exploit running
- Thanks to Victor for your assistence in tracing the Slim 3000 syscon pinouts
- Greets to those in the assorted chat rooms that welcomed me back from retirement with open arms and patience while I got back up to speed again
- Thank you N. for your unyielding support in my hobbies.

# Abbreviations
- CFW - Custom Firmware
- HIG - IBM Hardware Initialization Guide for the Cell
- NVS - Non-Volatile Storage
- TOCTOU - Time of Check, Time of Use
- Syscon - System Controller

# History Lesson: Where did we leave off?
The PlayStation 3 has had very long homebrew story. At the initial release of the PS3, Linux support was baked in on day 1! People had the ability to install any PowerPC based distribution with full kernel support for the assorted system devices. This enabled all sorts of interesting uses like supercomputing clusters and a cheap PowerPC development box. There was some poking and prodding done from Linux to the hypervisor but nobody really bothered to dig too far until OtherOS support was removed from slim consoles. After the release of GeoHot's HTAB exploit, OtherOS was removed from all consoles in 3.21. This was the catalyst which opened the floodgates to complete exploit of the console. I've summarized the current state of many exploits released for the PS3 console below:

| Exploit | Version | Enabled in LV1 | Enabled in LV2 | Notes |
| --- | --- | --- | --- | --- |
| GeoHot HTAB Glitching | Any? | R/W Arbitrary HV Memory | N/A | FPGA used to glitch memory address lines |
| PSJailbreak Dongle | 3.41 | N/A | Homebrew and Piracy in GameOS, OtherOS support restored | Dongles exploited USB device descriptor parsing to get code execution in LV2. |
| fail0verflow Sigfail | <= 3.55 | Custom-signed LV1 | Custom-signed LV2 | Works on all consoles with a minver of <= 3.55. |
| **Post 3.55/Sigfail Era** |
| lv0ldr Syscon Packet TOCTOU - Linux Dumping | Any? | N/A | N/A | Dumped the lv0 root keys to allow decrypting of all LV0 executables and signing on <= 3.55 minver consoles. |
| HEN | <= 4.89 | N/A | Homebrew and Piracy in GameOS | No OtherOS support | 
| lv0ldr Syscon Packet TOCTOU - HW Remix | Any? | Custom code in LV1 | Custom code in LV2 | Should work on all consoles with HW. This is today's topic! |

After the release of the sigfail exploit, Sony attempted to re-secure the bootchain by moving all loaders into lv0 as that had yet to be dumped or exploited. This was a good stop-gap solution until Juan Nadie and the Three Musketeers dumped lv0ldr and their exploit and keys were leaked. Once the LV0 keys were available, it was now possible to modify and re-sign all updatable code on older consoles. Consoles manufactured after the sigfail release were updated with new lv0 metadata (lv0.2) which is not vulnerable to the sigfail exploit.

- Cell BE Bootrom -> lv0ldr (per-console encrypted) -> lv0
    + Pre 3.60: lv0 -> metldr -> lv1ldr -> lv1 -> lv2ldr -> lv2 -> appldr-> vsh
    + 3.60+: lv0 -> Scrambled loaders stored in lv0 -> metldr -> lv1ldr -> lv1 -> lv2ldr -> lv2 -> appldr -> vsh

More information about the PS3 boot chain is available [here](https://www.psdevwiki.com/ps3/Boot_Order).

For all consoles which were not vulnerable to sigfail, HEN was released which exploited both the built-in web browser and LV2 kernel to enable both homebrew and piracy in GameOS. This still does not allow for OtherOS support or hypervisor modification to this day.

# PlayStation 3 SPI Architecture
Specific to this writeup, the PS3 architecture pieces we're interested in are Syscon and its SPI busses. The bus of interest is `SPI01` which is the SPI bus between Syscon and Southbridge. This is the main bus used for interacting with syscon for NVS read/write, temperature monitoring, fan control, and system boot up.

```
                      ┌────────┐
           ┌─────────►│        │
           │   SPI00  │ CELL   │
           │ ┌────────┤        │
           │ │        └────────┘
           │ ▼
      ┌────┴───┐      ┌────────┐
      │        ├─────►│        │
      │ Syscon │SPI11 │ RSX    │
      │        │◄─────┤        │
      └────┬───┘      └────────┘
           │ ▲
           │ │        ┌────────┐
           │ └────────┤        │
           │   SPI01  │ South  │
           └─────────►│ Bridge │
                      │        │
                      └────────┘
```
Syscon SPI busses as seen on a CECH-2500.

# Syscon/SB SPI Bus
## Overview
Syscon SPI bus `SPI01` is a SPI bus running at 2.5 MHz and 3.3v between SB and Syscon. There are 6 pins of note; the usual four SPI pins (CLK, #CE, CIPO, COPI) and two interrupt pins (#BE_INT, #SB_INT). The controller is Syscon and the peripheral is SB.

```
    ┌────────────┐ 2  #SB_INT     ┌────────────┐
    │            │◄───────────────┤            │
    │            │                │            │
    │            │ 3  #BE_INT     │            │
    │            │◄──────────     ┤            │
    │            │                │            │
    │   Syscon   │ 80  SB_SPI_DO  │  South     │
    │            ├───────────────►│  Bridge    │
    │   SW2-303  │                │            │
    │            │ 81  SB_SPI_DI  │            │
    │            │◄───────────────┤            │
    │            │                │            │
    │            │ 82  SB_SPI_CLK │            │
    │            ├───────────────►│            │
    │            │                │            │
    │            │ 83 #SB_SPI_CS  │            │
    │            ├───────────────►│            │
    └────────────┘                └────────────┘
```
Syscon (SW2-303) SPI lines and connections to SB. Numbers by Syscon correspond to the pin number for a SW2-303 model.

| Pin Name | Description | Notes |
| --- | --- | --- |
| #CE | Chip Enable | Active low |
| CLK | SPI Clock | _Nominally_ 2.5 MHz, held high at rest |
| COPI | Controller Out, Peripheral In |
| CIPO | Controller In, Peripheral Out |
| #BE_INT | Cell Interrupt | Maps to the `ATTENTION` signal described in the HIG |
| #SB_INT | Southbridge Interrupt signal | Used to notify Syscon that a packet from Cell is ready to be processed |

## Bus Transfer Protocol
IBM describes the SPI transfer protocol in use for the Cell BE as part of the HIG (Section 3). The Syscon/SB bus also uses the same protocol. Of note:

- All transfers except the configuration ring occur with MSB sent first
- Cell/SB samples serial input on the rising edge of the clock and outputs data on the falling edge (SPI Mode 2)
- SPI transfers start on the first rising clock edge after #CE is asserted
- Specific to the PS3, the resting clock value is 1

When transferring data from Syscon to SB, the same sequence is always followed for simple SPI writes. There are other modes of operation but only simple read/writes are of interest in this write up.
The SPI command is transferred first. The command byte is decoded as:
```
MSB             LSB
 +---------------+
 |0|1|2|3|4|5|6|7|
 +---------------+

Bits 0 - 3: Chip ID
Bits 4 - 5: Multichip ID
Bits 6 - 7: Command

Chip ID:
0000 - Serial SPI Memory
0001 - Cell BE Processor
0010 - IOIF0 Device
0011 - IOIF1 Device
0100 - System Controller
0101 - Reserved
011x - Reserved
1xxx - Reserved

Multichip ID:
00 - Cell BE Processor 0
01 - Cell BE Processor 1
10 - Cell BE Processor 2
11 - Cell BE Processor 3

Command:
00 - Read
01 - Write
1x - Reserved
```

For purposes in this document, the two main commands used for reading and writing to syscon packet buffers are:

- 0x30: Read from IOIF1
- 0x31: Write to IOIF1

After the command byte, the next two bytes are the address. Commonly used addresses are described below:

| SPI Address | Size | Description |
| --- | --- | --- |
| 0xA000 | 0xFF0 | Syscon to Cell Packet Buffer |
| 0xAFF0 | 0x4 | Syscon to Cell Packet Counter |
| 0xB000 | 0xFF0 | Cell to Syscon Packet Buffer |
| 0xBFF0 | 0x4 | Cell to Syscon Packet Counter |
| 0x9104 | 0x4 | Syscon to SB SPI Doorbell - Data written to 0xA000 will not be visible to Cell until 0x00000001 is written to this address |

Once the address is written to the SPI bus, the remainder of the transfer is data to that address. For the packet buffers, reads and writes can be arbitrary lengths. When transferring 16 bytes data to, say, 0xA000, it could either be written in a single SPI transaction with 16 bytes of data or across 4 separate SPI transactions (of 4 bytes each) with the addresses 0xA000, 0xA004, 0xA008, 0xA00C.

- Insert picture of SPI trace from syscon showing a sample read/write with timings

Now that the SPI transfer protocol is clear, let's move one level up to examine the packet protocol between Syscon and Cell. A rough decoder for DSView is available [here](https://github.com/MikeM64/ps3_sc_spi).

## Syscon SPI Packet Protocol
Building on top of the SPI protocol between Syscon and SB is a packet interface to interface with different services (NVS, fan, temperature, etc...) provided by syscon. A single packet transfer is built up of a header, body and checksum. To transfer a packet from syscon to SB:

1. A header is built and written to 0xA000

    The packet header follows the following structure:
    ```c
    struct sc_packet_header {
        /* Service ID of 0x14 corresponds to an NVS read */
        uint8_t     service_id;
        /* Always 1 */
        uint8_t     version;
        /* Response from SC */
        uint16_t    transaction_id;
        /* Result code */
        uint8_t     result[2];
        /* Checksum of a portion of the header - See calculate_sc_packet_header_cksum */
        uint16_t    sc_pkt_hdr_cksum;
        /* 0 for most boot-time transfers */
        uint32_t    communication_tag;
        /* Message body length, both values must match */
        uint16_t    body_size[2];
    };
    
    uint16_t
    calculate_sc_packet_header_cksum (struct sc_packet_header *pkt_hdr)
    {
        uint8_t     *pkt_hdr_u8 = (uint8_t *)pkt_hdr;
        uint16_t     cksum = 0;
        size_t       i;
    
        for (i = 0; i < 6; i++) {
            cksum += *pkt_hdr_u8++;
        }
    
        cksum += 0x8000;
    
        return (cksum);
    }
    ```

2. The message body is written after the header (`0xA010`)
3. A checksum is calculated over both the header and body. This checksum is then written to the 4 bytes after the end of the body.

    ```c
    uint16_t
    calculate_sc_packet_cksum (uint8_t *pkt_buf, size_t pkt_len)
    {
        uint32_t    cksum = 0;
        size_t      i;
    
        for (i = 0; i < pkt_len; i++) {
            cksum -= pkt_buf[i];
        }
    
        return (cksum & 0xffff);
    }
    ```

4. The appropriate packet counter is incremented by 1
5. To notify the other side of an awaiting packet:
    - Syscon will write `0x1` to the SPI address `0x9104` to make the contents of the `0xA000` address space visible in Cell MMIO space. Code running on the Cell would be monitoring for a change in the SC packet counters before processing a new one.
    - Cell will write `0x1` to the MMIO address `0x2400008e100`. This will assert the `#SB_INT` pin to notify syscon to read the `0xB000` SPI address space for a packet.

Now that we can see a packet being transferred from Syscon to Cell and back, here's a useful table to map between the SPI address space and MMIO address space:

| SPI Address | MMIO Address | Description |
| --- | --- | --- |
| 0xA000 | 0x2400008c000 | Syscon to SB packet buffer |
| 0xB000 | 0x2400008d000 | SB to Syscon packet buffer |

# Juan Nadie's lv0ldr Software Exploit

The `lv0ldr` exploit used to dump lv0ldr targets the processing of syscon packets between syscon and SB/Cell. It was disovered in `lv0` that the code which manages syscon packet reads had a TOCTOU bug in it which re-reads the packet header after validation. From nwert's blog post on the bug:

```c
//In .data section.
static u8 tmp_pkt[0x800];
 
//Get size from sc packet.
#define GET_SIZE(pkt) ((pkt[4] << 8) | pkt[5])
 
int read_cmpl_msg(/*...*/, u8 *payload_buf /*r5*/, int min_size /*r6*/, /*...*/)
{
    u16 pkt_size;
 
    //Get packet header.
    memcpy_aligned_64(tmp_pkt, MMIO_SC_PKT, 0x10);
 
    //Check packet size.
    pkt_size = GET_SIZE(tmp_pkt);
    if(pkt_size - 4 < min_size || pkt_size + 8 > 0x800)
        return ERR;
 
    //Run first sc_checksum.
    if(!sc_checksum(...))
        return ERR;
 
    //Read packet again (plus header!).
    pkt_size = GET_SIZE(tmp_pkt);
    memcpy_aligned_64(tmp_pkt, MMIO_SC_PKT, size + 0x1B);
 
    //Get size again (not checked now).
    //I suspect that this is actually a compiler 'quirk' and not a
    //programmer mistake. The original source probably accesses the
    //packet size through a structure and the compiler noticed the
    //non const access of the packet and generated this read of the
    //size member because it could have changed.
    pkt_size = GET_SIZE(tmp_pkt);
 
    //Let's have some fun (payload_buf on caller stack).
    memcpy(payload_buf, tmp_pkt + 8, size - 4);
 
    //Run second sc_checksum.
    if(!sc_checksum(...))
        return ERR;
 
    //...
}
```

This issue alone would not normally be enough to exploit lv0ldr. You'd have to be able to time and inject memory writes to the MMIO space containing the syscon packet buffer in order to pass the first checksum and then write the new header to exploit the memcpy of arbitrary size. The timing window to exploit this is extremely, extremely tiny. Luckily, we can arbitrarily expand this timing window thanks to debugging facilities that IBM left in the Cell. For both regular and isolated SPUs, we can turn on interrupts for any MFC transfers in or out of the SPU. This allows us to pause execution of lv0ldr on any memory access, enabling the exploit and dumping lv0ldr.

For the `lv0ldr` exploit to be usable, there is some required scaffolding in addition to the TOCTOU of the packet header:
- Setup of a large NVS read to pre-populate the stack with a useful return address somewhere in the shared LS (0x3e000 or above)
- External DMA into the shared portion of the LS to install the shellcode

This allows dumping of lv0ldr, but no further experimentation as it was not possible at the time to populate one of the undocumented SPU channels with the appropriate config ring used during a normal boot up. The config ring is transferred over the BE_SPI bus (SPI00).

# Working backwards from outside to inside
With a working method to dump lv0ldr the question posed nearly a decade ago was: **How do we do this from hardware?**

This can be broken down into multiple parts:

1. Gaining arbitrary SPI read and write from an external device
2. Finding ways to replicate the software exploit without existing code execution
    + How to get the stack primed with a useful return address?
    + How to get the shellcode into the SPU shared LS?
        * No linux available to copy shellcode from PPE to SPU
    + What can be used instead of SPU interrupts to trigger the exploit?
        * Can't watch for each memory/dma request in/out of the SPU
        * Is it even possible to race the second read external to the Cell?

## Arbitrary SPI Read and Write
The first step in recreating the software exploit using external hardware was to be able to understand how SPI transactions worked. My faithful PS3 slim became the hardware testbed to trial all of these SPI experiments.

![ps3-slim-spi-wiring](https://github.com/mikem64/Exploit-Writeups/raw/main/PS3/lv0ldr-spi-mitm/img/ps3-slim-spi-wiring.jpg)

I started by bifurcating the SPI bus between syscon and SB to be able to attach my own controller (a Teensy 4.0) to the SPI bus. I wrote a small test program to trigger a Syscon beep when running under PS3 linux. This allowed me to capture known syscon packets over the SPI bus. With this information, it was now possible to see how a packet was sent from SB to Syscon and how Syscon sent the response back to SB. I then attempted to write arbitrary data from the Teensy back into the Cell MMIO space. The `0x9104` doorbell is specific to SB, so it took a bit longer than I'd like to admit to see a successful write from my own controller into Cell MMIO space...

![spi-write-mike](https://github.com/mikem64/Exploit-Writeups/raw/main/PS3/lv0ldr-spi-mitm/img/spi-write-mike.jpg)

Once I had SPI write, SPI read followed soon after. This led to the discovery that I needed more pins bifurcated (specifically the `#BE_INT` and `#SB_INT` ones). When writing a packet from SB to Syscon, there is a doorbell in Cell MMIO space at `0x2400008e100`. When this doorbell is written, two things happen:

1. The MMIO space is reflected into SPI space
2. The `#SB_INT` line is asserted

When `#SB_INT` is asserted, this notifies Syscon that a packet is ready to be read from SPI space. If syscon isn't connected to the SPI bus, it'll get garbage data when it tries to read and panic. This means that in order for Syscon to not turn off the PS3 every time Cell writes a packet the interrupt lines must also be cut.

## Dynamic Controller Selection
For this to be usable with the exploit, there must be a way to dynamically change which controller is interacting with SB at a given time. I'm not looking to emulate syscon, just modify specific requests and inject little bits of custom data. I started work on a [board to enable SPI MITM](https://github.com/MikeM64/spi-controller-mux) which became a fun way to re-learn PCB design and also an annoying way to learn about ground bounce and loops. I ended up abandoning the debugging of this board as I was struggling with signal integrity issues and wanted to move forward with the development of this exploit.

![ps3-slim-spi-mux](https://github.com/mikem64/Exploit-Writeups/raw/main/PS3/lv0ldr-spi-mitm/img/ps3-slim-spi-mux.jpg)

The next idea for dynamically controlling the SPI peripheral was to use the Teensy as the MITM device and have it proxy all requests to and from SB. This could have simplified the hardware needed to experiment with SPI but ran into challenges with both SPI library support on Teensy 4.0 (Peripheral mode is not well supported) as well as the data transfer latency from Syscon to Cell. Syscon transfers are very oddly spaced as there is a lot of time in between bytes of a given transfer. Once the last byte is transmitted there is not much of a window before #CE is de-asserted. I ended up discarding this idea due to the timing concerns.

![spi-write-timing-1](https://github.com/mikem64/Exploit-Writeups/raw/main/PS3/lv0ldr-spi-mitm/img/spi-write-timing-1.png)
![spi-write-timing-2](https://github.com/mikem64/Exploit-Writeups/raw/main/PS3/lv0ldr-spi-mitm/img/spi-write-timing-2.png)

An [Arty S7-50 FPGA development board](https://github.com/MikeM64/spi-mitm) was used to act as a mux/demux instead. This simplified hardware debugging as the board is a known-good quantity and didn't introduce any additional transfer latency like a proxying Teensy would. The block diagram of the hardware involved is below:

```
+--------+          +------+         +----------+
|        |<---------+      |<--------+          |
|  Cell  |          | FPGA |         |  Syscon  |
|        +--------->|      +-------->|          |
+--------+          +-+----+         +----------+
                      |   ^
                      |   |          +----------+
                      |   +----------+          |
                      |              |  Teensy  |
                      +------------->|          |
                                     +----------+
```

![ps3-slim-arty-teensy-final](https://github.com/mikem64/Exploit-Writeups/raw/main/PS3/lv0ldr-spi-mitm/img/ps3-slim-arty-teensy-final.jpg)

This meant I could now read and write the packet buffers over SPI at any time without causing any syscon panics!

## Priming lv0ldr
With the help of Jestero, he identified some possible Syscon packets during boot up which could be a potential vector to get data into lv0ldr. The NVS read service has a minor bug where the response length (Syscon to SB) is not checked against the requested read length of the original packet. This is not an issue on its own as the maximum body size is still capped at 260 bytes. By padding the NVS read response packet up to the maximum supported body length, it was possible to put a controlled return address onto the stack and have lv0ldr copy shellcode out of MMIO space into the shared LS.

We know to target the NVS read service packets to get data into the SPU. To manage that externally, the Teensy was placed in peripheral mode to silently sniff the SPI bus during boot up. Once the appropriate packet header was seen the Teensy disconnected the SPI bus from Syscon and became a controller itself. It then writes the crafted NVS read response packet to prime the LS with both the controlled return address and the stage 1 shellcode. It is extremely lucky that it was possible to fit a shellcode into the read response. Without a DMA request coming from the SPU, there would be no other way to get code or data into the shared LS. The stage 1 shellcode triggers another DMA request to copy the entire SC packet buffer (`0x2400008c000`, length 0x1000) into the shared LS and jump to `0x3e120`.

As an aside with the SPI bus disconnected, the boot sequence of the PS3 can be stepped through by controlling when syscon gets interrupt requests from Cell. You can take as long as you want to boot in this manner.

## Replacing SPU Interrupts with Luck
It's now possible to intercept SPI transfers and inject crafted data into the buffers. The remaining piece of the puzzle is triggering the exploit using another packet request. Remember, the trigger is:

1. Write a valid packet
2. Wait long enough for the original length to be checked and checksum to be calculated (must be a valid one!)
3. Write a crafted header with long, unvalidated length before the header is read a second time

At boot time, the Cell runs at approximately 400 MHz. This doesn't leave much time between the two syscon packet header reads. From all other experimentation the SPI bus runs at 2.5 MHz. This did not bode well for success. At least until IBM came through again with another gem in the HIG: _"(assuming an SPI master that reads the SPI at a clock rate as slow as 100 MHz)"_. This provided a bit of hope that the SPI bus can run much faster than the 2.5 MHz syscon is running it at! There was a **lot** of trial and error at this point to see what would happen when writing the crafted length at different times after the original packet was written. There's one of three outcomes that could be seen:

1. Teensy writes the modified length too quickly after to the original, valid packet

    This leads to the crafted body length of the message no longer matching the valid length orignally written and the checksum subsequently fails.

    ```
    read_cmpl_msg_ver1: too small payload_size 16, body_len 256
    send_and_receive: read_cmpl_msg fail -7
    read_cmpl_msg_ver1: payload checksum 55280 != 37234
    send_and_receive: read_cmpl_msg fail -6
    ```

2. Teensy writes too slowly (too late) compared to the original, valid packet

    The PS3 will boot normally, just missed the window. Time to speed up the SPI bus and keep trying...

3. Teensy writes just in time to trigger the exploit

    Turns out that it's possible to run the SPI bus at 25 MHz, which provides enough time to spare to race the second read of the packet header! There was a lot of trial-and-error coupled with pure luck to find the magic window. If you need to track down a timing window, performing a binary search over the possible window range really help to shrink the search space.

![spi-exploit-write-timing](https://github.com/mikem64/Exploit-Writeups/raw/main/PS3/lv0ldr-spi-mitm/img/spi-exploit-write-timing.png)

The timing window for success is:
- 4.036us from the completion of the doorbell write to the completion of the modified length write
- 3.592us from the completion of the modified length write to the completion of the modified checksum write
- Each of the above writes should take no more than 3.38us from start to completion

![lv0ldr-hello-world](https://github.com/mikem64/Exploit-Writeups/raw/main/PS3/lv0ldr-spi-mitm/img/lv0ldr-hello-world.jpg)

Code execution has now been achieved on lv0ldr during boot up. The time code execution occurs is before the config ring is read via the undocumented SPU channels. There is the possibility of toying with config ring settings once we understand how the config ring is sent to the PS3 Cell.

The door is now open for the community to build on this work to create modchips and CFW on late-model slims and super-slims. It may also even be possible to trigger this exploit from a syscon patch removing all external HW. I've created a repository to contain useful lv0ldr payloads and provide a template for creating a new one [here](https://github.com/MikeM64/lv0ldr-payloads). Happy Hacking!

# CECH-2500 Exploit Setup
Recreating this exploit on another CECH-2500 requires the following hardware:
- CECH-2500 PS3
- Teensy 4.0 (Not 4.1, but it could be possible to port to it very easily)
- Arty S7-50 (S7-35 or A7 series is also possible to port the SPI MITM code to)
- Good soldering skills and/or breakout boards to cut and intercept the following traces:
    + Pinout available [here](https://www.psdevwiki.com/ps3/SW2-303)
    + BE_SPI_CLK
    + BE_SPI_CE
    + BE_SPI_DO
    + BE_SPI_DI
    + BE_INT
        * Not necessesarily required but done for completeness
    + SB_INT

Software wise:
- Vivado 2020.2 to build and flash [spi-mitm](https://github.com/MikeM64/spi-mitm)
- PS3 SPU GCC Toolchain to compile the [lv0ldr payloads](https://github.com/MikeM64/lv0ldr-payloads)
- Teensyduino to compile and flash the [teensy side of the exploit](https://github.com/MikeM64/ps3-lv0ldr-teensy)
- Some sort of serial console application (puTTy, minicom, realterm, etc...)

## Prerequisites
- The PS3 must have the following flags set in syscon to get the proper debugging messages over SB UART:
    + After autenticating with syscon over SC UART, run the following commands
    + `w 1202 02` - Enable SB UART as debug output (debug interface)
    + `w 1211 03` - Enable additional lv0ldr logging (bootrom trace level)

## Hardware setup
Start by soldering all 12 wires to the pins listed above. I strongly suggest you solder 6 wires to the appropriate syscon pins and the other 6 to the next closest via or component on the board. (See previous pictures for ideas). Once you've confirmed you've got a good connection, cut the traces between the two solder joints. Test your connections by jumpering the pins. The PS3 will still boot normally with the pins jumpered.

![hw-exploit-schematic](https://github.com/mikem64/Exploit-Writeups/raw/main/PS3/lv0ldr-spi-mitm/img/PS3-FPGA-Teensy.png)

With all 12 wires available, connect them to the arty per the pins in the constraint file [here](https://github.com/MikeM64/spi-mitm/blob/main/src/constr/arty-s7-50.xdc). Peripheral corresponds to the SB-side pins, controller 0 corresponds to the syscon-side pins, and controller 1 corresponds to the [teensy pins for SPI0](https://www.pjrc.com/store/teensy40.html). Pin 2 of the teensy should be wired to the pin `controller1_int_en_i` and pin 3 of the teensy should be wired to `controller1_spi_en_i`. Ground should be common between teensy, PS3 and Arty boards.

## Running the exploit
Flash the arty board with `spi-mitm` and then flash the teensy with `ps3-lv0ldr-teensy`. This will run a payload on boot which dumps the contents of the isolated SPU local store (dumping lv0ldr in the process). Start up the serial monitor to point to the Teensy's USB Serial port and then start the PS3. If all works, you'll see lv0ldr fly by on the console. Reflash the teensy to run another payload (rebooting the teensy isn't working at the moment).

# References
- IBM Cell Hardware Initialization Guide - 90nm
- PS3 Dev Wiki
    + https://www.psdevwiki.com/ps3/SC_Communication
    + https://www.psdevwiki.com/ps3/Hypervisor_Reverse_Engineering#Calculating_Packet_Header_Checksum
- https://nwert.wordpress.com/2012/11/20/the-exploit/
- https://fahrplan.events.ccc.de/congress/2010/Fahrplan/attachments/1780_27c3_console_hacking_2010.pdf

# Appendices
## Hardware Inventory
- PS3 Slim - CECH-2500
- Siglent SDS1104X-E
- DSLogic U3Pro16
- Arty S7-50
- Teensy 4.0

## SPU Programming Gotchas
- All DMA transfers of < 16 bytes must have the same low four bits in both the source and destination addresses, otherwise an alignment error is triggered
    + 0x3e000 -> 0x24000fff31c == Alignment error
    + 0x3e00c -> 0x24000fff31c == Success
